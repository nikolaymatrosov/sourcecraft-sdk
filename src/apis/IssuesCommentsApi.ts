/* tslint:disable */
/* eslint-disable */
/**
 * SourceCraft API
 * Bleeding edge of Public REST API of SourceCraft
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: info@sourcecraft.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
    ApiErrorResponse,
    CreateIssueCommentBody,
    IssueComment,
    ListIssueCommentsResponse,
    UpdateIssueCommentBody,
} from "../models/index";
import {
    ApiErrorResponseFromJSON,
    ApiErrorResponseToJSON,
    CreateIssueCommentBodyFromJSON,
    CreateIssueCommentBodyToJSON,
    IssueCommentFromJSON,
    IssueCommentToJSON,
    ListIssueCommentsResponseFromJSON,
    ListIssueCommentsResponseToJSON,
    UpdateIssueCommentBodyFromJSON,
    UpdateIssueCommentBodyToJSON,
} from "../models/index";

export interface CreateIssueCommentRequest {
    orgSlug: string;
    repoSlug: string;
    issueSlug: string;
    createIssueCommentBody: CreateIssueCommentBody;
    silent?: boolean;
}

export interface CreateIssueCommentByIDRequest {
    issueId: string;
    createIssueCommentBody: CreateIssueCommentBody;
    silent?: boolean;
}

export interface DeleteIssueCommentRequest {
    issueCommentId: string;
    silent?: boolean;
}

export interface GetIssueCommentRequest {
    issueCommentId: string;
}

export interface ListIssueCommentsRequest {
    orgSlug: string;
    repoSlug: string;
    issueSlug: string;
    pageSize?: string;
    pageToken?: string;
    sortBy?: string;
}

export interface ListIssueCommentsByIDRequest {
    issueId: string;
    pageSize?: string;
    pageToken?: string;
    sortBy?: string;
}

export interface UpdateIssueCommentRequest {
    issueCommentId: string;
    updateIssueCommentBody: UpdateIssueCommentBody;
    silent?: boolean;
}

/**
 * IssuesCommentsApi - interface
 *
 * @export
 * @interface IssuesCommentsApiInterface
 */
export interface IssuesCommentsApiInterface {
    /**
     *
     * @summary Create comment
     * @param {string} orgSlug
     * @param {string} repoSlug
     * @param {string} issueSlug
     * @param {CreateIssueCommentBody} createIssueCommentBody
     * @param {boolean} [silent] do not notify subscribers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesCommentsApiInterface
     */
    createIssueCommentRaw(
        requestParameters: CreateIssueCommentRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<IssueComment>>;

    /**
     * Create comment
     */
    createIssueComment(
        requestParameters: CreateIssueCommentRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<IssueComment>;

    /**
     *
     * @summary Create comment (by Issue ID)
     * @param {string} issueId
     * @param {CreateIssueCommentBody} createIssueCommentBody
     * @param {boolean} [silent] do not notify subscribers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesCommentsApiInterface
     */
    createIssueCommentByIDRaw(
        requestParameters: CreateIssueCommentByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<IssueComment>>;

    /**
     * Create comment (by Issue ID)
     */
    createIssueCommentByID(
        requestParameters: CreateIssueCommentByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<IssueComment>;

    /**
     * Permanently deletes a comment from an issue. This action cannot be undone.
     * @summary Delete Comment
     * @param {string} issueCommentId
     * @param {boolean} [silent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesCommentsApiInterface
     */
    deleteIssueCommentRaw(
        requestParameters: DeleteIssueCommentRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<void>>;

    /**
     * Permanently deletes a comment from an issue. This action cannot be undone.
     * Delete Comment
     */
    deleteIssueComment(
        requestParameters: DeleteIssueCommentRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<void>;

    /**
     *
     * @summary Get Comment
     * @param {string} issueCommentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesCommentsApiInterface
     */
    getIssueCommentRaw(
        requestParameters: GetIssueCommentRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<IssueComment>>;

    /**
     * Get Comment
     */
    getIssueComment(
        requestParameters: GetIssueCommentRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<IssueComment>;

    /**
     * Retrieves comments for an issue
     * @summary List Comments
     * @param {string} orgSlug
     * @param {string} repoSlug
     * @param {string} issueSlug
     * @param {string} [pageSize] The maximum number of issues to return. The service may return fewer than this value
     * @param {string} [pageToken] A page token, received from a previous call. Provide this to retrieve the subsequent page.  When paginating, all other parameters must match the call that provided the page token.
     * @param {string} [sortBy] Ordering options: comma separated list of fields. For example: \&quot;name, created_at\&quot; Default sorting order is ascending. To specify descending order for a field, append a \&quot;-\&quot; prefix; for example: \&quot;name, -created_at\&quot; Redundant space characters in the syntax are insignificant. \&quot;foo, -bar\&quot;, \&quot; foo , -bar\&quot;, and \&quot;foo,bar\&quot; are all equivalent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesCommentsApiInterface
     */
    listIssueCommentsRaw(
        requestParameters: ListIssueCommentsRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<ListIssueCommentsResponse>>;

    /**
     * Retrieves comments for an issue
     * List Comments
     */
    listIssueComments(
        requestParameters: ListIssueCommentsRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<ListIssueCommentsResponse>;

    /**
     * Retrieves comments for an issue
     * @summary List Comments (by ID)
     * @param {string} issueId
     * @param {string} [pageSize] The maximum number of issues to return. The service may return fewer than this value
     * @param {string} [pageToken] A page token, received from a previous call. Provide this to retrieve the subsequent page.  When paginating, all other parameters must match the call that provided the page token.
     * @param {string} [sortBy] Ordering options: comma separated list of fields. For example: \&quot;name, created_at\&quot; Default sorting order is ascending. To specify descending order for a field, append a \&quot;-\&quot; prefix; for example: \&quot;name, -created_at\&quot; Redundant space characters in the syntax are insignificant. \&quot;foo, -bar\&quot;, \&quot; foo , -bar\&quot;, and \&quot;foo,bar\&quot; are all equivalent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesCommentsApiInterface
     */
    listIssueCommentsByIDRaw(
        requestParameters: ListIssueCommentsByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<ListIssueCommentsResponse>>;

    /**
     * Retrieves comments for an issue
     * List Comments (by ID)
     */
    listIssueCommentsByID(
        requestParameters: ListIssueCommentsByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<ListIssueCommentsResponse>;

    /**
     * Update a comment
     * @summary Update Comment
     * @param {string} issueCommentId
     * @param {UpdateIssueCommentBody} updateIssueCommentBody
     * @param {boolean} [silent] do not notify subscribers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesCommentsApiInterface
     */
    updateIssueCommentRaw(
        requestParameters: UpdateIssueCommentRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<IssueComment>>;

    /**
     * Update a comment
     * Update Comment
     */
    updateIssueComment(
        requestParameters: UpdateIssueCommentRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<IssueComment>;
}

/**
 *
 */
export class IssuesCommentsApi extends runtime.BaseAPI implements IssuesCommentsApiInterface {
    /**
     * Create comment
     */
    async createIssueCommentRaw(
        requestParameters: CreateIssueCommentRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<IssueComment>> {
        if (requestParameters["orgSlug"] == null) {
            throw new runtime.RequiredError(
                "orgSlug",
                'Required parameter "orgSlug" was null or undefined when calling createIssueComment().'
            );
        }

        if (requestParameters["repoSlug"] == null) {
            throw new runtime.RequiredError(
                "repoSlug",
                'Required parameter "repoSlug" was null or undefined when calling createIssueComment().'
            );
        }

        if (requestParameters["issueSlug"] == null) {
            throw new runtime.RequiredError(
                "issueSlug",
                'Required parameter "issueSlug" was null or undefined when calling createIssueComment().'
            );
        }

        if (requestParameters["createIssueCommentBody"] == null) {
            throw new runtime.RequiredError(
                "createIssueCommentBody",
                'Required parameter "createIssueCommentBody" was null or undefined when calling createIssueComment().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["silent"] != null) {
            queryParameters["silent"] = requestParameters["silent"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/issues/{issue_slug}/comments`;
        urlPath = urlPath.replace(
            `{${"org_slug"}}`,
            encodeURIComponent(String(requestParameters["orgSlug"]))
        );
        urlPath = urlPath.replace(
            `{${"repo_slug"}}`,
            encodeURIComponent(String(requestParameters["repoSlug"]))
        );
        urlPath = urlPath.replace(
            `{${"issue_slug"}}`,
            encodeURIComponent(String(requestParameters["issueSlug"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: CreateIssueCommentBodyToJSON(requestParameters["createIssueCommentBody"]),
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) =>
            IssueCommentFromJSON(jsonValue)
        );
    }

    /**
     * Create comment
     */
    async createIssueComment(
        requestParameters: CreateIssueCommentRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<IssueComment> {
        const response = await this.createIssueCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create comment (by Issue ID)
     */
    async createIssueCommentByIDRaw(
        requestParameters: CreateIssueCommentByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<IssueComment>> {
        if (requestParameters["issueId"] == null) {
            throw new runtime.RequiredError(
                "issueId",
                'Required parameter "issueId" was null or undefined when calling createIssueCommentByID().'
            );
        }

        if (requestParameters["createIssueCommentBody"] == null) {
            throw new runtime.RequiredError(
                "createIssueCommentBody",
                'Required parameter "createIssueCommentBody" was null or undefined when calling createIssueCommentByID().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["silent"] != null) {
            queryParameters["silent"] = requestParameters["silent"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/issues/id:{issue_id}/comments`;
        urlPath = urlPath.replace(
            `{${"issue_id"}}`,
            encodeURIComponent(String(requestParameters["issueId"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: CreateIssueCommentBodyToJSON(requestParameters["createIssueCommentBody"]),
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) =>
            IssueCommentFromJSON(jsonValue)
        );
    }

    /**
     * Create comment (by Issue ID)
     */
    async createIssueCommentByID(
        requestParameters: CreateIssueCommentByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<IssueComment> {
        const response = await this.createIssueCommentByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Permanently deletes a comment from an issue. This action cannot be undone.
     * Delete Comment
     */
    async deleteIssueCommentRaw(
        requestParameters: DeleteIssueCommentRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<void>> {
        if (requestParameters["issueCommentId"] == null) {
            throw new runtime.RequiredError(
                "issueCommentId",
                'Required parameter "issueCommentId" was null or undefined when calling deleteIssueComment().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["silent"] != null) {
            queryParameters["silent"] = requestParameters["silent"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/issue_comments/id:{issue_comment_id}`;
        urlPath = urlPath.replace(
            `{${"issue_comment_id"}}`,
            encodeURIComponent(String(requestParameters["issueCommentId"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "DELETE",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Permanently deletes a comment from an issue. This action cannot be undone.
     * Delete Comment
     */
    async deleteIssueComment(
        requestParameters: DeleteIssueCommentRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<void> {
        await this.deleteIssueCommentRaw(requestParameters, initOverrides);
    }

    /**
     * Get Comment
     */
    async getIssueCommentRaw(
        requestParameters: GetIssueCommentRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<IssueComment>> {
        if (requestParameters["issueCommentId"] == null) {
            throw new runtime.RequiredError(
                "issueCommentId",
                'Required parameter "issueCommentId" was null or undefined when calling getIssueComment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/issue_comments/id:{issue_comment_id}`;
        urlPath = urlPath.replace(
            `{${"issue_comment_id"}}`,
            encodeURIComponent(String(requestParameters["issueCommentId"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) =>
            IssueCommentFromJSON(jsonValue)
        );
    }

    /**
     * Get Comment
     */
    async getIssueComment(
        requestParameters: GetIssueCommentRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<IssueComment> {
        const response = await this.getIssueCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves comments for an issue
     * List Comments
     */
    async listIssueCommentsRaw(
        requestParameters: ListIssueCommentsRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<ListIssueCommentsResponse>> {
        if (requestParameters["orgSlug"] == null) {
            throw new runtime.RequiredError(
                "orgSlug",
                'Required parameter "orgSlug" was null or undefined when calling listIssueComments().'
            );
        }

        if (requestParameters["repoSlug"] == null) {
            throw new runtime.RequiredError(
                "repoSlug",
                'Required parameter "repoSlug" was null or undefined when calling listIssueComments().'
            );
        }

        if (requestParameters["issueSlug"] == null) {
            throw new runtime.RequiredError(
                "issueSlug",
                'Required parameter "issueSlug" was null or undefined when calling listIssueComments().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["pageSize"] != null) {
            queryParameters["page_size"] = requestParameters["pageSize"];
        }

        if (requestParameters["pageToken"] != null) {
            queryParameters["page_token"] = requestParameters["pageToken"];
        }

        if (requestParameters["sortBy"] != null) {
            queryParameters["sort_by"] = requestParameters["sortBy"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/issues/{issue_slug}/comments`;
        urlPath = urlPath.replace(
            `{${"org_slug"}}`,
            encodeURIComponent(String(requestParameters["orgSlug"]))
        );
        urlPath = urlPath.replace(
            `{${"repo_slug"}}`,
            encodeURIComponent(String(requestParameters["repoSlug"]))
        );
        urlPath = urlPath.replace(
            `{${"issue_slug"}}`,
            encodeURIComponent(String(requestParameters["issueSlug"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) =>
            ListIssueCommentsResponseFromJSON(jsonValue)
        );
    }

    /**
     * Retrieves comments for an issue
     * List Comments
     */
    async listIssueComments(
        requestParameters: ListIssueCommentsRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<ListIssueCommentsResponse> {
        const response = await this.listIssueCommentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves comments for an issue
     * List Comments (by ID)
     */
    async listIssueCommentsByIDRaw(
        requestParameters: ListIssueCommentsByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<ListIssueCommentsResponse>> {
        if (requestParameters["issueId"] == null) {
            throw new runtime.RequiredError(
                "issueId",
                'Required parameter "issueId" was null or undefined when calling listIssueCommentsByID().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["pageSize"] != null) {
            queryParameters["page_size"] = requestParameters["pageSize"];
        }

        if (requestParameters["pageToken"] != null) {
            queryParameters["page_token"] = requestParameters["pageToken"];
        }

        if (requestParameters["sortBy"] != null) {
            queryParameters["sort_by"] = requestParameters["sortBy"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/issues/id:{issue_id}/comments`;
        urlPath = urlPath.replace(
            `{${"issue_id"}}`,
            encodeURIComponent(String(requestParameters["issueId"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) =>
            ListIssueCommentsResponseFromJSON(jsonValue)
        );
    }

    /**
     * Retrieves comments for an issue
     * List Comments (by ID)
     */
    async listIssueCommentsByID(
        requestParameters: ListIssueCommentsByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<ListIssueCommentsResponse> {
        const response = await this.listIssueCommentsByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a comment
     * Update Comment
     */
    async updateIssueCommentRaw(
        requestParameters: UpdateIssueCommentRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<IssueComment>> {
        if (requestParameters["issueCommentId"] == null) {
            throw new runtime.RequiredError(
                "issueCommentId",
                'Required parameter "issueCommentId" was null or undefined when calling updateIssueComment().'
            );
        }

        if (requestParameters["updateIssueCommentBody"] == null) {
            throw new runtime.RequiredError(
                "updateIssueCommentBody",
                'Required parameter "updateIssueCommentBody" was null or undefined when calling updateIssueComment().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["silent"] != null) {
            queryParameters["silent"] = requestParameters["silent"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/issue_comments/id:{issue_comment_id}`;
        urlPath = urlPath.replace(
            `{${"issue_comment_id"}}`,
            encodeURIComponent(String(requestParameters["issueCommentId"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "PATCH",
                headers: headerParameters,
                query: queryParameters,
                body: UpdateIssueCommentBodyToJSON(requestParameters["updateIssueCommentBody"]),
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) =>
            IssueCommentFromJSON(jsonValue)
        );
    }

    /**
     * Update a comment
     * Update Comment
     */
    async updateIssueComment(
        requestParameters: UpdateIssueCommentRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<IssueComment> {
        const response = await this.updateIssueCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
