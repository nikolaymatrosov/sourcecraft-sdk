/* tslint:disable */
/* eslint-disable */
/**
 * SourceCraft API
 * Bleeding edge of Public REST API of SourceCraft
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: info@sourcecraft.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ApiErrorResponse,
  CreateIssueBody,
  Issue,
  ListIssuesAssignedToAuthenticatedUserResponse,
  ListRepositoryIssuesResponse,
  UpdateIssueBody,
} from '../models/index';
import {
    ApiErrorResponseFromJSON,
    ApiErrorResponseToJSON,
    CreateIssueBodyFromJSON,
    CreateIssueBodyToJSON,
    IssueFromJSON,
    IssueToJSON,
    ListIssuesAssignedToAuthenticatedUserResponseFromJSON,
    ListIssuesAssignedToAuthenticatedUserResponseToJSON,
    ListRepositoryIssuesResponseFromJSON,
    ListRepositoryIssuesResponseToJSON,
    UpdateIssueBodyFromJSON,
    UpdateIssueBodyToJSON,
} from '../models/index';

export interface CreateIssueRequest {
    orgSlug: string;
    repoSlug: string;
    createIssueBody: CreateIssueBody;
    silent?: boolean;
}

export interface CreateIssueByIDRequest {
    repoId: string;
    createIssueBody: CreateIssueBody;
    silent?: boolean;
}

export interface DeleteIssueRequest {
    orgSlug: string;
    repoSlug: string;
    issueSlug: string;
    silent?: boolean;
}

export interface DeleteIssueByIDRequest {
    issueId: string;
    silent?: boolean;
}

export interface GetIssueRequest {
    orgSlug: string;
    repoSlug: string;
    issueSlug: string;
}

export interface GetIssueByIDRequest {
    issueId: string;
}

export interface ListIssuesAssignedToAuthenticatedUserRequest {
    pageSize?: string;
    pageToken?: string;
    sortBy?: string;
    filter?: string;
}

export interface ListRepositoryIssuesRequest {
    orgSlug: string;
    repoSlug: string;
    pageSize?: string;
    pageToken?: string;
    sortBy?: string;
    filter?: string;
}

export interface ListRepositoryIssuesByIDRequest {
    repoId: string;
    pageSize?: string;
    pageToken?: string;
    sortBy?: string;
    filter?: string;
}

export interface UpdateIssueRequest {
    orgSlug: string;
    repoSlug: string;
    issueSlug: string;
    updateIssueBody: UpdateIssueBody;
    silent?: boolean;
}

export interface UpdateIssueByIDRequest {
    issueId: string;
    updateIssueBody: UpdateIssueBody;
    silent?: boolean;
}

/**
 * 
 */
export class IssuesApi extends runtime.BaseAPI {

    /**
     * Create Issue in Repository
     */
    async createIssueRaw(requestParameters: CreateIssueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Issue>> {
        if (requestParameters['orgSlug'] == null) {
            throw new runtime.RequiredError(
                'orgSlug',
                'Required parameter "orgSlug" was null or undefined when calling createIssue().'
            );
        }

        if (requestParameters['repoSlug'] == null) {
            throw new runtime.RequiredError(
                'repoSlug',
                'Required parameter "repoSlug" was null or undefined when calling createIssue().'
            );
        }

        if (requestParameters['createIssueBody'] == null) {
            throw new runtime.RequiredError(
                'createIssueBody',
                'Required parameter "createIssueBody" was null or undefined when calling createIssue().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['silent'] != null) {
            queryParameters['silent'] = requestParameters['silent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/issues`;
        urlPath = urlPath.replace(`{${"org_slug"}}`, encodeURIComponent(String(requestParameters['orgSlug'])));
        urlPath = urlPath.replace(`{${"repo_slug"}}`, encodeURIComponent(String(requestParameters['repoSlug'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateIssueBodyToJSON(requestParameters['createIssueBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IssueFromJSON(jsonValue));
    }

    /**
     * Create Issue in Repository
     */
    async createIssue(requestParameters: CreateIssueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Issue> {
        const response = await this.createIssueRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Issue in Repository (By Repo ID)
     */
    async createIssueByIDRaw(requestParameters: CreateIssueByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Issue>> {
        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling createIssueByID().'
            );
        }

        if (requestParameters['createIssueBody'] == null) {
            throw new runtime.RequiredError(
                'createIssueBody',
                'Required parameter "createIssueBody" was null or undefined when calling createIssueByID().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['silent'] != null) {
            queryParameters['silent'] = requestParameters['silent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/id:{repo_id}/issues`;
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateIssueBodyToJSON(requestParameters['createIssueBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IssueFromJSON(jsonValue));
    }

    /**
     * Create Issue in Repository (By Repo ID)
     */
    async createIssueByID(requestParameters: CreateIssueByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Issue> {
        const response = await this.createIssueByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete Issue
     */
    async deleteIssueRaw(requestParameters: DeleteIssueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgSlug'] == null) {
            throw new runtime.RequiredError(
                'orgSlug',
                'Required parameter "orgSlug" was null or undefined when calling deleteIssue().'
            );
        }

        if (requestParameters['repoSlug'] == null) {
            throw new runtime.RequiredError(
                'repoSlug',
                'Required parameter "repoSlug" was null or undefined when calling deleteIssue().'
            );
        }

        if (requestParameters['issueSlug'] == null) {
            throw new runtime.RequiredError(
                'issueSlug',
                'Required parameter "issueSlug" was null or undefined when calling deleteIssue().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['silent'] != null) {
            queryParameters['silent'] = requestParameters['silent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/issues/{issue_slug}`;
        urlPath = urlPath.replace(`{${"org_slug"}}`, encodeURIComponent(String(requestParameters['orgSlug'])));
        urlPath = urlPath.replace(`{${"repo_slug"}}`, encodeURIComponent(String(requestParameters['repoSlug'])));
        urlPath = urlPath.replace(`{${"issue_slug"}}`, encodeURIComponent(String(requestParameters['issueSlug'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Issue
     */
    async deleteIssue(requestParameters: DeleteIssueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteIssueRaw(requestParameters, initOverrides);
    }

    /**
     * Delete Issue (By Issue ID)
     */
    async deleteIssueByIDRaw(requestParameters: DeleteIssueByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['issueId'] == null) {
            throw new runtime.RequiredError(
                'issueId',
                'Required parameter "issueId" was null or undefined when calling deleteIssueByID().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['silent'] != null) {
            queryParameters['silent'] = requestParameters['silent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/issues/id:{issue_id}`;
        urlPath = urlPath.replace(`{${"issue_id"}}`, encodeURIComponent(String(requestParameters['issueId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Issue (By Issue ID)
     */
    async deleteIssueByID(requestParameters: DeleteIssueByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteIssueByIDRaw(requestParameters, initOverrides);
    }

    /**
     * Get Issue
     */
    async getIssueRaw(requestParameters: GetIssueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Issue>> {
        if (requestParameters['orgSlug'] == null) {
            throw new runtime.RequiredError(
                'orgSlug',
                'Required parameter "orgSlug" was null or undefined when calling getIssue().'
            );
        }

        if (requestParameters['repoSlug'] == null) {
            throw new runtime.RequiredError(
                'repoSlug',
                'Required parameter "repoSlug" was null or undefined when calling getIssue().'
            );
        }

        if (requestParameters['issueSlug'] == null) {
            throw new runtime.RequiredError(
                'issueSlug',
                'Required parameter "issueSlug" was null or undefined when calling getIssue().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/issues/{issue_slug}`;
        urlPath = urlPath.replace(`{${"org_slug"}}`, encodeURIComponent(String(requestParameters['orgSlug'])));
        urlPath = urlPath.replace(`{${"repo_slug"}}`, encodeURIComponent(String(requestParameters['repoSlug'])));
        urlPath = urlPath.replace(`{${"issue_slug"}}`, encodeURIComponent(String(requestParameters['issueSlug'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IssueFromJSON(jsonValue));
    }

    /**
     * Get Issue
     */
    async getIssue(requestParameters: GetIssueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Issue> {
        const response = await this.getIssueRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Issue (By ID)
     */
    async getIssueByIDRaw(requestParameters: GetIssueByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Issue>> {
        if (requestParameters['issueId'] == null) {
            throw new runtime.RequiredError(
                'issueId',
                'Required parameter "issueId" was null or undefined when calling getIssueByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/issues/id:{issue_id}`;
        urlPath = urlPath.replace(`{${"issue_id"}}`, encodeURIComponent(String(requestParameters['issueId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IssueFromJSON(jsonValue));
    }

    /**
     * Get Issue (By ID)
     */
    async getIssueByID(requestParameters: GetIssueByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Issue> {
        const response = await this.getIssueByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of issues that are either assigned to or created by the currently authenticated user.
     * My Issues
     */
    async listIssuesAssignedToAuthenticatedUserRaw(requestParameters: ListIssuesAssignedToAuthenticatedUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListIssuesAssignedToAuthenticatedUserResponse>> {
        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['pageToken'] != null) {
            queryParameters['page_token'] = requestParameters['pageToken'];
        }

        if (requestParameters['sortBy'] != null) {
            queryParameters['sort_by'] = requestParameters['sortBy'];
        }

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/me/issues`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListIssuesAssignedToAuthenticatedUserResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of issues that are either assigned to or created by the currently authenticated user.
     * My Issues
     */
    async listIssuesAssignedToAuthenticatedUser(requestParameters: ListIssuesAssignedToAuthenticatedUserRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListIssuesAssignedToAuthenticatedUserResponse> {
        const response = await this.listIssuesAssignedToAuthenticatedUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Repository Issues
     */
    async listRepositoryIssuesRaw(requestParameters: ListRepositoryIssuesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListRepositoryIssuesResponse>> {
        if (requestParameters['orgSlug'] == null) {
            throw new runtime.RequiredError(
                'orgSlug',
                'Required parameter "orgSlug" was null or undefined when calling listRepositoryIssues().'
            );
        }

        if (requestParameters['repoSlug'] == null) {
            throw new runtime.RequiredError(
                'repoSlug',
                'Required parameter "repoSlug" was null or undefined when calling listRepositoryIssues().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['pageToken'] != null) {
            queryParameters['page_token'] = requestParameters['pageToken'];
        }

        if (requestParameters['sortBy'] != null) {
            queryParameters['sort_by'] = requestParameters['sortBy'];
        }

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/issues`;
        urlPath = urlPath.replace(`{${"org_slug"}}`, encodeURIComponent(String(requestParameters['orgSlug'])));
        urlPath = urlPath.replace(`{${"repo_slug"}}`, encodeURIComponent(String(requestParameters['repoSlug'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListRepositoryIssuesResponseFromJSON(jsonValue));
    }

    /**
     * List Repository Issues
     */
    async listRepositoryIssues(requestParameters: ListRepositoryIssuesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListRepositoryIssuesResponse> {
        const response = await this.listRepositoryIssuesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Repository Issues (By Repo ID)
     */
    async listRepositoryIssuesByIDRaw(requestParameters: ListRepositoryIssuesByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListRepositoryIssuesResponse>> {
        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling listRepositoryIssuesByID().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['pageToken'] != null) {
            queryParameters['page_token'] = requestParameters['pageToken'];
        }

        if (requestParameters['sortBy'] != null) {
            queryParameters['sort_by'] = requestParameters['sortBy'];
        }

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/id:{repo_id}/issues`;
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListRepositoryIssuesResponseFromJSON(jsonValue));
    }

    /**
     * List Repository Issues (By Repo ID)
     */
    async listRepositoryIssuesByID(requestParameters: ListRepositoryIssuesByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListRepositoryIssuesResponse> {
        const response = await this.listRepositoryIssuesByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Issue
     */
    async updateIssueRaw(requestParameters: UpdateIssueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Issue>> {
        if (requestParameters['orgSlug'] == null) {
            throw new runtime.RequiredError(
                'orgSlug',
                'Required parameter "orgSlug" was null or undefined when calling updateIssue().'
            );
        }

        if (requestParameters['repoSlug'] == null) {
            throw new runtime.RequiredError(
                'repoSlug',
                'Required parameter "repoSlug" was null or undefined when calling updateIssue().'
            );
        }

        if (requestParameters['issueSlug'] == null) {
            throw new runtime.RequiredError(
                'issueSlug',
                'Required parameter "issueSlug" was null or undefined when calling updateIssue().'
            );
        }

        if (requestParameters['updateIssueBody'] == null) {
            throw new runtime.RequiredError(
                'updateIssueBody',
                'Required parameter "updateIssueBody" was null or undefined when calling updateIssue().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['silent'] != null) {
            queryParameters['silent'] = requestParameters['silent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/issues/{issue_slug}`;
        urlPath = urlPath.replace(`{${"org_slug"}}`, encodeURIComponent(String(requestParameters['orgSlug'])));
        urlPath = urlPath.replace(`{${"repo_slug"}}`, encodeURIComponent(String(requestParameters['repoSlug'])));
        urlPath = urlPath.replace(`{${"issue_slug"}}`, encodeURIComponent(String(requestParameters['issueSlug'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateIssueBodyToJSON(requestParameters['updateIssueBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IssueFromJSON(jsonValue));
    }

    /**
     * Update Issue
     */
    async updateIssue(requestParameters: UpdateIssueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Issue> {
        const response = await this.updateIssueRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Issue (By Issue ID)
     */
    async updateIssueByIDRaw(requestParameters: UpdateIssueByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Issue>> {
        if (requestParameters['issueId'] == null) {
            throw new runtime.RequiredError(
                'issueId',
                'Required parameter "issueId" was null or undefined when calling updateIssueByID().'
            );
        }

        if (requestParameters['updateIssueBody'] == null) {
            throw new runtime.RequiredError(
                'updateIssueBody',
                'Required parameter "updateIssueBody" was null or undefined when calling updateIssueByID().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['silent'] != null) {
            queryParameters['silent'] = requestParameters['silent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/issues/id:{issue_id}`;
        urlPath = urlPath.replace(`{${"issue_id"}}`, encodeURIComponent(String(requestParameters['issueId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateIssueBodyToJSON(requestParameters['updateIssueBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IssueFromJSON(jsonValue));
    }

    /**
     * Update Issue (By Issue ID)
     */
    async updateIssueByID(requestParameters: UpdateIssueByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Issue> {
        const response = await this.updateIssueByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
