/* tslint:disable */
/* eslint-disable */
/**
 * SourceCraft API
 * Bleeding edge of Public REST API of SourceCraft
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: info@sourcecraft.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
    ApiErrorResponse,
    CreateReleaseBody,
    ListReleasesResponse,
    Release,
} from "../models/index";
import {
    ApiErrorResponseFromJSON,
    ApiErrorResponseToJSON,
    CreateReleaseBodyFromJSON,
    CreateReleaseBodyToJSON,
    ListReleasesResponseFromJSON,
    ListReleasesResponseToJSON,
    ReleaseFromJSON,
    ReleaseToJSON,
} from "../models/index";

export interface CreateRequest {
    orgSlug: string;
    repoSlug: string;
    createReleaseBody: CreateReleaseBody;
}

export interface CreateByIDRequest {
    repoId: string;
    createReleaseBody: CreateReleaseBody;
}

export interface DiscardByIDRequest {
    releaseId: string;
    releaseTag?: string;
}

export interface DiscardByTagRequest {
    orgSlug: string;
    repoSlug: string;
    releaseTag: string;
    releaseId?: string;
}

export interface GetByIDRequest {
    releaseId: string;
    releaseTag?: string;
}

export interface GetByTagRequest {
    orgSlug: string;
    repoSlug: string;
    releaseTag: string;
    releaseId?: string;
}

export interface GetLatestRequest {
    orgSlug: string;
    repoSlug: string;
}

export interface GetLatestByIDRequest {
    repoId: string;
}

export interface ListRequest {
    orgSlug: string;
    repoSlug: string;
    pageSize?: string;
    pageToken?: string;
    sortBy?: string;
}

export interface ListByIDRequest {
    repoId: string;
    pageSize?: string;
    pageToken?: string;
    sortBy?: string;
}

export interface PublishByIDRequest {
    releaseId: string;
    releaseTag?: string;
}

export interface PublishByTagRequest {
    orgSlug: string;
    repoSlug: string;
    releaseTag: string;
    releaseId?: string;
}

/**
 * RepositoryReleasesApi - interface
 *
 * @export
 * @interface RepositoryReleasesApiInterface
 */
export interface RepositoryReleasesApiInterface {
    /**
     *
     * @summary Create Release in Repository
     * @param {string} orgSlug
     * @param {string} repoSlug
     * @param {CreateReleaseBody} createReleaseBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryReleasesApiInterface
     */
    createRaw(
        requestParameters: CreateRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Release>>;

    /**
     * Create Release in Repository
     */
    create(
        requestParameters: CreateRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Release>;

    /**
     *
     * @summary Create Release in Repository (By Repo ID)
     * @param {string} repoId
     * @param {CreateReleaseBody} createReleaseBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryReleasesApiInterface
     */
    createByIDRaw(
        requestParameters: CreateByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Release>>;

    /**
     * Create Release in Repository (By Repo ID)
     */
    createByID(
        requestParameters: CreateByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Release>;

    /**
     * Only \'published\' releases may be discarded, drafts can only be deleted or published. Contrary to deleted releases, discarded releases are still visible to maintainers.
     * @summary Discard Release (By ID)
     * @param {string} releaseId
     * @param {string} [releaseTag]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryReleasesApiInterface
     */
    discardByIDRaw(
        requestParameters: DiscardByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Release>>;

    /**
     * Only \'published\' releases may be discarded, drafts can only be deleted or published. Contrary to deleted releases, discarded releases are still visible to maintainers.
     * Discard Release (By ID)
     */
    discardByID(
        requestParameters: DiscardByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Release>;

    /**
     * Only \'published\' releases may be discarded, drafts can only be deleted or published. Contrary to deleted releases, discarded releases are still visible to maintainers.
     * @summary Discard Release (By Tag)
     * @param {string} orgSlug
     * @param {string} repoSlug
     * @param {string} releaseTag
     * @param {string} [releaseId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryReleasesApiInterface
     */
    discardByTagRaw(
        requestParameters: DiscardByTagRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Release>>;

    /**
     * Only \'published\' releases may be discarded, drafts can only be deleted or published. Contrary to deleted releases, discarded releases are still visible to maintainers.
     * Discard Release (By Tag)
     */
    discardByTag(
        requestParameters: DiscardByTagRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Release>;

    /**
     *
     * @summary Get Release (By ID)
     * @param {string} releaseId
     * @param {string} [releaseTag]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryReleasesApiInterface
     */
    getByIDRaw(
        requestParameters: GetByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Release>>;

    /**
     * Get Release (By ID)
     */
    getByID(
        requestParameters: GetByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Release>;

    /**
     *
     * @summary Get Release (By Tag)
     * @param {string} orgSlug
     * @param {string} repoSlug
     * @param {string} releaseTag
     * @param {string} [releaseId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryReleasesApiInterface
     */
    getByTagRaw(
        requestParameters: GetByTagRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Release>>;

    /**
     * Get Release (By Tag)
     */
    getByTag(
        requestParameters: GetByTagRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Release>;

    /**
     * Retrieves a release marked as latest (by default, last published release)
     * @summary Get Latest Release
     * @param {string} orgSlug
     * @param {string} repoSlug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryReleasesApiInterface
     */
    getLatestRaw(
        requestParameters: GetLatestRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Release>>;

    /**
     * Retrieves a release marked as latest (by default, last published release)
     * Get Latest Release
     */
    getLatest(
        requestParameters: GetLatestRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Release>;

    /**
     * Retrieves a release marked as latest (by default, last published release)
     * @summary Get Latest Release (By Repo ID)
     * @param {string} repoId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryReleasesApiInterface
     */
    getLatestByIDRaw(
        requestParameters: GetLatestByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Release>>;

    /**
     * Retrieves a release marked as latest (by default, last published release)
     * Get Latest Release (By Repo ID)
     */
    getLatestByID(
        requestParameters: GetLatestByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Release>;

    /**
     *
     * @summary List Releases in Repository
     * @param {string} orgSlug
     * @param {string} repoSlug
     * @param {string} [pageSize] The maximum number of releases to return. The service may return fewer than this value
     * @param {string} [pageToken] A page token, received from a previous call. Provide this to retrieve the subsequent page.  When paginating, all other parameters must match the call that provided the page token.
     * @param {string} [sortBy] Ordering options: comma separated list of fields. For example: \&quot;name, created_at\&quot; Default sorting order is ascending. To specify descending order for a field, append a \&quot;-\&quot; prefix; for example: \&quot;name, -created_at\&quot; Redundant space characters in the syntax are insignificant. \&quot;foo, -bar\&quot;, \&quot; foo , -bar\&quot;, and \&quot;foo,bar\&quot; are all equivalent. Available fields: created_at, released_at
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryReleasesApiInterface
     */
    listRaw(
        requestParameters: ListRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<ListReleasesResponse>>;

    /**
     * List Releases in Repository
     */
    list(
        requestParameters: ListRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<ListReleasesResponse>;

    /**
     *
     * @summary List Releases in Repository (By Repo ID)
     * @param {string} repoId
     * @param {string} [pageSize] The maximum number of releases to return. The service may return fewer than this value
     * @param {string} [pageToken] A page token, received from a previous call. Provide this to retrieve the subsequent page.  When paginating, all other parameters must match the call that provided the page token.
     * @param {string} [sortBy] Ordering options: comma separated list of fields. For example: \&quot;name, created_at\&quot; Default sorting order is ascending. To specify descending order for a field, append a \&quot;-\&quot; prefix; for example: \&quot;name, -created_at\&quot; Redundant space characters in the syntax are insignificant. \&quot;foo, -bar\&quot;, \&quot; foo , -bar\&quot;, and \&quot;foo,bar\&quot; are all equivalent. Available fields: created_at, released_at
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryReleasesApiInterface
     */
    listByIDRaw(
        requestParameters: ListByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<ListReleasesResponse>>;

    /**
     * List Releases in Repository (By Repo ID)
     */
    listByID(
        requestParameters: ListByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<ListReleasesResponse>;

    /**
     * Only \'draft\' releases may be published
     * @summary Publish Release (By ID)
     * @param {string} releaseId
     * @param {string} [releaseTag]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryReleasesApiInterface
     */
    publishByIDRaw(
        requestParameters: PublishByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Release>>;

    /**
     * Only \'draft\' releases may be published
     * Publish Release (By ID)
     */
    publishByID(
        requestParameters: PublishByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Release>;

    /**
     * Only \'draft\' releases may be published
     * @summary Publish Release (By Tag)
     * @param {string} orgSlug
     * @param {string} repoSlug
     * @param {string} releaseTag
     * @param {string} [releaseId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryReleasesApiInterface
     */
    publishByTagRaw(
        requestParameters: PublishByTagRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Release>>;

    /**
     * Only \'draft\' releases may be published
     * Publish Release (By Tag)
     */
    publishByTag(
        requestParameters: PublishByTagRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Release>;
}

/**
 *
 */
export class RepositoryReleasesApi
    extends runtime.BaseAPI
    implements RepositoryReleasesApiInterface
{
    /**
     * Create Release in Repository
     */
    async createRaw(
        requestParameters: CreateRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Release>> {
        if (requestParameters["orgSlug"] == null) {
            throw new runtime.RequiredError(
                "orgSlug",
                'Required parameter "orgSlug" was null or undefined when calling create().'
            );
        }

        if (requestParameters["repoSlug"] == null) {
            throw new runtime.RequiredError(
                "repoSlug",
                'Required parameter "repoSlug" was null or undefined when calling create().'
            );
        }

        if (requestParameters["createReleaseBody"] == null) {
            throw new runtime.RequiredError(
                "createReleaseBody",
                'Required parameter "createReleaseBody" was null or undefined when calling create().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/releases`;
        urlPath = urlPath.replace(
            `{${"org_slug"}}`,
            encodeURIComponent(String(requestParameters["orgSlug"]))
        );
        urlPath = urlPath.replace(
            `{${"repo_slug"}}`,
            encodeURIComponent(String(requestParameters["repoSlug"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: CreateReleaseBodyToJSON(requestParameters["createReleaseBody"]),
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ReleaseFromJSON(jsonValue));
    }

    /**
     * Create Release in Repository
     */
    async create(
        requestParameters: CreateRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Release> {
        const response = await this.createRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Release in Repository (By Repo ID)
     */
    async createByIDRaw(
        requestParameters: CreateByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Release>> {
        if (requestParameters["repoId"] == null) {
            throw new runtime.RequiredError(
                "repoId",
                'Required parameter "repoId" was null or undefined when calling createByID().'
            );
        }

        if (requestParameters["createReleaseBody"] == null) {
            throw new runtime.RequiredError(
                "createReleaseBody",
                'Required parameter "createReleaseBody" was null or undefined when calling createByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/id:{repo_id}/releases`;
        urlPath = urlPath.replace(
            `{${"repo_id"}}`,
            encodeURIComponent(String(requestParameters["repoId"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: CreateReleaseBodyToJSON(requestParameters["createReleaseBody"]),
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ReleaseFromJSON(jsonValue));
    }

    /**
     * Create Release in Repository (By Repo ID)
     */
    async createByID(
        requestParameters: CreateByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Release> {
        const response = await this.createByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Only \'published\' releases may be discarded, drafts can only be deleted or published. Contrary to deleted releases, discarded releases are still visible to maintainers.
     * Discard Release (By ID)
     */
    async discardByIDRaw(
        requestParameters: DiscardByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Release>> {
        if (requestParameters["releaseId"] == null) {
            throw new runtime.RequiredError(
                "releaseId",
                'Required parameter "releaseId" was null or undefined when calling discardByID().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["releaseTag"] != null) {
            queryParameters["release_tag"] = requestParameters["releaseTag"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/releases/id:{release_id}/discard`;
        urlPath = urlPath.replace(
            `{${"release_id"}}`,
            encodeURIComponent(String(requestParameters["releaseId"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ReleaseFromJSON(jsonValue));
    }

    /**
     * Only \'published\' releases may be discarded, drafts can only be deleted or published. Contrary to deleted releases, discarded releases are still visible to maintainers.
     * Discard Release (By ID)
     */
    async discardByID(
        requestParameters: DiscardByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Release> {
        const response = await this.discardByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Only \'published\' releases may be discarded, drafts can only be deleted or published. Contrary to deleted releases, discarded releases are still visible to maintainers.
     * Discard Release (By Tag)
     */
    async discardByTagRaw(
        requestParameters: DiscardByTagRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Release>> {
        if (requestParameters["orgSlug"] == null) {
            throw new runtime.RequiredError(
                "orgSlug",
                'Required parameter "orgSlug" was null or undefined when calling discardByTag().'
            );
        }

        if (requestParameters["repoSlug"] == null) {
            throw new runtime.RequiredError(
                "repoSlug",
                'Required parameter "repoSlug" was null or undefined when calling discardByTag().'
            );
        }

        if (requestParameters["releaseTag"] == null) {
            throw new runtime.RequiredError(
                "releaseTag",
                'Required parameter "releaseTag" was null or undefined when calling discardByTag().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["releaseId"] != null) {
            queryParameters["release_id"] = requestParameters["releaseId"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/releases/tag/{release_tag}/discard`;
        urlPath = urlPath.replace(
            `{${"org_slug"}}`,
            encodeURIComponent(String(requestParameters["orgSlug"]))
        );
        urlPath = urlPath.replace(
            `{${"repo_slug"}}`,
            encodeURIComponent(String(requestParameters["repoSlug"]))
        );
        urlPath = urlPath.replace(
            `{${"release_tag"}}`,
            encodeURIComponent(String(requestParameters["releaseTag"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ReleaseFromJSON(jsonValue));
    }

    /**
     * Only \'published\' releases may be discarded, drafts can only be deleted or published. Contrary to deleted releases, discarded releases are still visible to maintainers.
     * Discard Release (By Tag)
     */
    async discardByTag(
        requestParameters: DiscardByTagRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Release> {
        const response = await this.discardByTagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Release (By ID)
     */
    async getByIDRaw(
        requestParameters: GetByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Release>> {
        if (requestParameters["releaseId"] == null) {
            throw new runtime.RequiredError(
                "releaseId",
                'Required parameter "releaseId" was null or undefined when calling getByID().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["releaseTag"] != null) {
            queryParameters["release_tag"] = requestParameters["releaseTag"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/releases/id:{release_id}`;
        urlPath = urlPath.replace(
            `{${"release_id"}}`,
            encodeURIComponent(String(requestParameters["releaseId"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ReleaseFromJSON(jsonValue));
    }

    /**
     * Get Release (By ID)
     */
    async getByID(
        requestParameters: GetByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Release> {
        const response = await this.getByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Release (By Tag)
     */
    async getByTagRaw(
        requestParameters: GetByTagRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Release>> {
        if (requestParameters["orgSlug"] == null) {
            throw new runtime.RequiredError(
                "orgSlug",
                'Required parameter "orgSlug" was null or undefined when calling getByTag().'
            );
        }

        if (requestParameters["repoSlug"] == null) {
            throw new runtime.RequiredError(
                "repoSlug",
                'Required parameter "repoSlug" was null or undefined when calling getByTag().'
            );
        }

        if (requestParameters["releaseTag"] == null) {
            throw new runtime.RequiredError(
                "releaseTag",
                'Required parameter "releaseTag" was null or undefined when calling getByTag().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["releaseId"] != null) {
            queryParameters["release_id"] = requestParameters["releaseId"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/releases/tag/{release_tag}`;
        urlPath = urlPath.replace(
            `{${"org_slug"}}`,
            encodeURIComponent(String(requestParameters["orgSlug"]))
        );
        urlPath = urlPath.replace(
            `{${"repo_slug"}}`,
            encodeURIComponent(String(requestParameters["repoSlug"]))
        );
        urlPath = urlPath.replace(
            `{${"release_tag"}}`,
            encodeURIComponent(String(requestParameters["releaseTag"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ReleaseFromJSON(jsonValue));
    }

    /**
     * Get Release (By Tag)
     */
    async getByTag(
        requestParameters: GetByTagRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Release> {
        const response = await this.getByTagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a release marked as latest (by default, last published release)
     * Get Latest Release
     */
    async getLatestRaw(
        requestParameters: GetLatestRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Release>> {
        if (requestParameters["orgSlug"] == null) {
            throw new runtime.RequiredError(
                "orgSlug",
                'Required parameter "orgSlug" was null or undefined when calling getLatest().'
            );
        }

        if (requestParameters["repoSlug"] == null) {
            throw new runtime.RequiredError(
                "repoSlug",
                'Required parameter "repoSlug" was null or undefined when calling getLatest().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/releases/latest`;
        urlPath = urlPath.replace(
            `{${"org_slug"}}`,
            encodeURIComponent(String(requestParameters["orgSlug"]))
        );
        urlPath = urlPath.replace(
            `{${"repo_slug"}}`,
            encodeURIComponent(String(requestParameters["repoSlug"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ReleaseFromJSON(jsonValue));
    }

    /**
     * Retrieves a release marked as latest (by default, last published release)
     * Get Latest Release
     */
    async getLatest(
        requestParameters: GetLatestRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Release> {
        const response = await this.getLatestRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a release marked as latest (by default, last published release)
     * Get Latest Release (By Repo ID)
     */
    async getLatestByIDRaw(
        requestParameters: GetLatestByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Release>> {
        if (requestParameters["repoId"] == null) {
            throw new runtime.RequiredError(
                "repoId",
                'Required parameter "repoId" was null or undefined when calling getLatestByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/id:{repo_id}/releases/latest`;
        urlPath = urlPath.replace(
            `{${"repo_id"}}`,
            encodeURIComponent(String(requestParameters["repoId"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ReleaseFromJSON(jsonValue));
    }

    /**
     * Retrieves a release marked as latest (by default, last published release)
     * Get Latest Release (By Repo ID)
     */
    async getLatestByID(
        requestParameters: GetLatestByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Release> {
        const response = await this.getLatestByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Releases in Repository
     */
    async listRaw(
        requestParameters: ListRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<ListReleasesResponse>> {
        if (requestParameters["orgSlug"] == null) {
            throw new runtime.RequiredError(
                "orgSlug",
                'Required parameter "orgSlug" was null or undefined when calling list().'
            );
        }

        if (requestParameters["repoSlug"] == null) {
            throw new runtime.RequiredError(
                "repoSlug",
                'Required parameter "repoSlug" was null or undefined when calling list().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["pageSize"] != null) {
            queryParameters["page_size"] = requestParameters["pageSize"];
        }

        if (requestParameters["pageToken"] != null) {
            queryParameters["page_token"] = requestParameters["pageToken"];
        }

        if (requestParameters["sortBy"] != null) {
            queryParameters["sort_by"] = requestParameters["sortBy"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/releases`;
        urlPath = urlPath.replace(
            `{${"org_slug"}}`,
            encodeURIComponent(String(requestParameters["orgSlug"]))
        );
        urlPath = urlPath.replace(
            `{${"repo_slug"}}`,
            encodeURIComponent(String(requestParameters["repoSlug"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) =>
            ListReleasesResponseFromJSON(jsonValue)
        );
    }

    /**
     * List Releases in Repository
     */
    async list(
        requestParameters: ListRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<ListReleasesResponse> {
        const response = await this.listRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Releases in Repository (By Repo ID)
     */
    async listByIDRaw(
        requestParameters: ListByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<ListReleasesResponse>> {
        if (requestParameters["repoId"] == null) {
            throw new runtime.RequiredError(
                "repoId",
                'Required parameter "repoId" was null or undefined when calling listByID().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["pageSize"] != null) {
            queryParameters["page_size"] = requestParameters["pageSize"];
        }

        if (requestParameters["pageToken"] != null) {
            queryParameters["page_token"] = requestParameters["pageToken"];
        }

        if (requestParameters["sortBy"] != null) {
            queryParameters["sort_by"] = requestParameters["sortBy"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/id:{repo_id}/releases`;
        urlPath = urlPath.replace(
            `{${"repo_id"}}`,
            encodeURIComponent(String(requestParameters["repoId"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) =>
            ListReleasesResponseFromJSON(jsonValue)
        );
    }

    /**
     * List Releases in Repository (By Repo ID)
     */
    async listByID(
        requestParameters: ListByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<ListReleasesResponse> {
        const response = await this.listByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Only \'draft\' releases may be published
     * Publish Release (By ID)
     */
    async publishByIDRaw(
        requestParameters: PublishByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Release>> {
        if (requestParameters["releaseId"] == null) {
            throw new runtime.RequiredError(
                "releaseId",
                'Required parameter "releaseId" was null or undefined when calling publishByID().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["releaseTag"] != null) {
            queryParameters["release_tag"] = requestParameters["releaseTag"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/releases/id:{release_id}/publish`;
        urlPath = urlPath.replace(
            `{${"release_id"}}`,
            encodeURIComponent(String(requestParameters["releaseId"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ReleaseFromJSON(jsonValue));
    }

    /**
     * Only \'draft\' releases may be published
     * Publish Release (By ID)
     */
    async publishByID(
        requestParameters: PublishByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Release> {
        const response = await this.publishByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Only \'draft\' releases may be published
     * Publish Release (By Tag)
     */
    async publishByTagRaw(
        requestParameters: PublishByTagRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Release>> {
        if (requestParameters["orgSlug"] == null) {
            throw new runtime.RequiredError(
                "orgSlug",
                'Required parameter "orgSlug" was null or undefined when calling publishByTag().'
            );
        }

        if (requestParameters["repoSlug"] == null) {
            throw new runtime.RequiredError(
                "repoSlug",
                'Required parameter "repoSlug" was null or undefined when calling publishByTag().'
            );
        }

        if (requestParameters["releaseTag"] == null) {
            throw new runtime.RequiredError(
                "releaseTag",
                'Required parameter "releaseTag" was null or undefined when calling publishByTag().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["releaseId"] != null) {
            queryParameters["release_id"] = requestParameters["releaseId"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/releases/tag/{release_tag}/publish`;
        urlPath = urlPath.replace(
            `{${"org_slug"}}`,
            encodeURIComponent(String(requestParameters["orgSlug"]))
        );
        urlPath = urlPath.replace(
            `{${"repo_slug"}}`,
            encodeURIComponent(String(requestParameters["repoSlug"]))
        );
        urlPath = urlPath.replace(
            `{${"release_tag"}}`,
            encodeURIComponent(String(requestParameters["releaseTag"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ReleaseFromJSON(jsonValue));
    }

    /**
     * Only \'draft\' releases may be published
     * Publish Release (By Tag)
     */
    async publishByTag(
        requestParameters: PublishByTagRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Release> {
        const response = await this.publishByTagRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
