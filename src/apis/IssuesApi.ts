/* tslint:disable */
/* eslint-disable */
/**
 * SourceCraft API
 * Bleeding edge of Public REST API of SourceCraft
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: info@sourcecraft.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
    ApiErrorResponse,
    CreateIssueBody,
    Issue,
    ListIssuesAssignedToAuthenticatedUserResponse,
    ListRepositoryIssuesResponse,
    UpdateIssueBody,
} from "../models/index";
import {
    ApiErrorResponseFromJSON,
    ApiErrorResponseToJSON,
    CreateIssueBodyFromJSON,
    CreateIssueBodyToJSON,
    IssueFromJSON,
    IssueToJSON,
    ListIssuesAssignedToAuthenticatedUserResponseFromJSON,
    ListIssuesAssignedToAuthenticatedUserResponseToJSON,
    ListRepositoryIssuesResponseFromJSON,
    ListRepositoryIssuesResponseToJSON,
    UpdateIssueBodyFromJSON,
    UpdateIssueBodyToJSON,
} from "../models/index";

export interface CreateIssueRequest {
    orgSlug: string;
    repoSlug: string;
    createIssueBody: CreateIssueBody;
    silent?: boolean;
}

export interface CreateIssueByIDRequest {
    repoId: string;
    createIssueBody: CreateIssueBody;
    silent?: boolean;
}

export interface DeleteIssueRequest {
    orgSlug: string;
    repoSlug: string;
    issueSlug: string;
    silent?: boolean;
}

export interface DeleteIssueByIDRequest {
    issueId: string;
    silent?: boolean;
}

export interface GetIssueRequest {
    orgSlug: string;
    repoSlug: string;
    issueSlug: string;
}

export interface GetIssueByIDRequest {
    issueId: string;
}

export interface ListIssuesAssignedToAuthenticatedUserRequest {
    pageSize?: string;
    pageToken?: string;
    sortBy?: string;
    filter?: string;
}

export interface ListRepositoryIssuesRequest {
    orgSlug: string;
    repoSlug: string;
    pageSize?: string;
    pageToken?: string;
    sortBy?: string;
    filter?: string;
}

export interface ListRepositoryIssuesByIDRequest {
    repoId: string;
    pageSize?: string;
    pageToken?: string;
    sortBy?: string;
    filter?: string;
}

export interface UpdateIssueRequest {
    orgSlug: string;
    repoSlug: string;
    issueSlug: string;
    updateIssueBody: UpdateIssueBody;
    silent?: boolean;
}

export interface UpdateIssueByIDRequest {
    issueId: string;
    updateIssueBody: UpdateIssueBody;
    silent?: boolean;
}

/**
 * IssuesApi - interface
 *
 * @export
 * @interface IssuesApiInterface
 */
export interface IssuesApiInterface {
    /**
     *
     * @summary Create Issue in Repository
     * @param {string} orgSlug
     * @param {string} repoSlug
     * @param {CreateIssueBody} createIssueBody
     * @param {boolean} [silent] do not notify subscribers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApiInterface
     */
    createIssueRaw(
        requestParameters: CreateIssueRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Issue>>;

    /**
     * Create Issue in Repository
     */
    createIssue(
        requestParameters: CreateIssueRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Issue>;

    /**
     *
     * @summary Create Issue in Repository (By Repo ID)
     * @param {string} repoId
     * @param {CreateIssueBody} createIssueBody
     * @param {boolean} [silent] do not notify subscribers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApiInterface
     */
    createIssueByIDRaw(
        requestParameters: CreateIssueByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Issue>>;

    /**
     * Create Issue in Repository (By Repo ID)
     */
    createIssueByID(
        requestParameters: CreateIssueByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Issue>;

    /**
     *
     * @summary Delete Issue
     * @param {string} orgSlug
     * @param {string} repoSlug
     * @param {string} issueSlug
     * @param {boolean} [silent] do not notify subscribers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApiInterface
     */
    deleteIssueRaw(
        requestParameters: DeleteIssueRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<void>>;

    /**
     * Delete Issue
     */
    deleteIssue(
        requestParameters: DeleteIssueRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<void>;

    /**
     *
     * @summary Delete Issue (By Issue ID)
     * @param {string} issueId
     * @param {boolean} [silent] do not notify subscribers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApiInterface
     */
    deleteIssueByIDRaw(
        requestParameters: DeleteIssueByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<void>>;

    /**
     * Delete Issue (By Issue ID)
     */
    deleteIssueByID(
        requestParameters: DeleteIssueByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<void>;

    /**
     *
     * @summary Get Issue
     * @param {string} orgSlug
     * @param {string} repoSlug
     * @param {string} issueSlug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApiInterface
     */
    getIssueRaw(
        requestParameters: GetIssueRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Issue>>;

    /**
     * Get Issue
     */
    getIssue(
        requestParameters: GetIssueRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Issue>;

    /**
     *
     * @summary Get Issue (By ID)
     * @param {string} issueId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApiInterface
     */
    getIssueByIDRaw(
        requestParameters: GetIssueByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Issue>>;

    /**
     * Get Issue (By ID)
     */
    getIssueByID(
        requestParameters: GetIssueByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Issue>;

    /**
     * Returns a list of issues that are either assigned to or created by the currently authenticated user.
     * @summary My Issues
     * @param {string} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [sortBy]
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApiInterface
     */
    listIssuesAssignedToAuthenticatedUserRaw(
        requestParameters: ListIssuesAssignedToAuthenticatedUserRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<ListIssuesAssignedToAuthenticatedUserResponse>>;

    /**
     * Returns a list of issues that are either assigned to or created by the currently authenticated user.
     * My Issues
     */
    listIssuesAssignedToAuthenticatedUser(
        requestParameters: ListIssuesAssignedToAuthenticatedUserRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<ListIssuesAssignedToAuthenticatedUserResponse>;

    /**
     *
     * @summary List Repository Issues
     * @param {string} orgSlug
     * @param {string} repoSlug
     * @param {string} [pageSize] The maximum number of issues to return. The service may return fewer than this value
     * @param {string} [pageToken] A page token, received from a previous call. Provide this to retrieve the subsequent page.  When paginating, all other parameters must match the call that provided the page token.
     * @param {string} [sortBy] Ordering options: comma separated list of fields. For example: \&quot;name, created_at\&quot; Default sorting order is ascending. To specify descending order for a field, append a \&quot;-\&quot; prefix; for example: \&quot;name, -created_at\&quot; Redundant space characters in the syntax are insignificant. \&quot;foo, -bar\&quot;, \&quot; foo , -bar\&quot;, and \&quot;foo,bar\&quot; are all equivalent.
     * @param {string} [filter] Filter using QL language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApiInterface
     */
    listRepositoryIssuesRaw(
        requestParameters: ListRepositoryIssuesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<ListRepositoryIssuesResponse>>;

    /**
     * List Repository Issues
     */
    listRepositoryIssues(
        requestParameters: ListRepositoryIssuesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<ListRepositoryIssuesResponse>;

    /**
     *
     * @summary List Repository Issues (By Repo ID)
     * @param {string} repoId
     * @param {string} [pageSize] The maximum number of issues to return. The service may return fewer than this value
     * @param {string} [pageToken] A page token, received from a previous call. Provide this to retrieve the subsequent page.  When paginating, all other parameters must match the call that provided the page token.
     * @param {string} [sortBy] Ordering options: comma separated list of fields. For example: \&quot;name, created_at\&quot; Default sorting order is ascending. To specify descending order for a field, append a \&quot;-\&quot; prefix; for example: \&quot;name, -created_at\&quot; Redundant space characters in the syntax are insignificant. \&quot;foo, -bar\&quot;, \&quot; foo , -bar\&quot;, and \&quot;foo,bar\&quot; are all equivalent.
     * @param {string} [filter] Filter using QL language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApiInterface
     */
    listRepositoryIssuesByIDRaw(
        requestParameters: ListRepositoryIssuesByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<ListRepositoryIssuesResponse>>;

    /**
     * List Repository Issues (By Repo ID)
     */
    listRepositoryIssuesByID(
        requestParameters: ListRepositoryIssuesByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<ListRepositoryIssuesResponse>;

    /**
     *
     * @summary Update Issue
     * @param {string} orgSlug
     * @param {string} repoSlug
     * @param {string} issueSlug
     * @param {UpdateIssueBody} updateIssueBody
     * @param {boolean} [silent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApiInterface
     */
    updateIssueRaw(
        requestParameters: UpdateIssueRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Issue>>;

    /**
     * Update Issue
     */
    updateIssue(
        requestParameters: UpdateIssueRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Issue>;

    /**
     *
     * @summary Update Issue (By Issue ID)
     * @param {string} issueId
     * @param {UpdateIssueBody} updateIssueBody
     * @param {boolean} [silent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApiInterface
     */
    updateIssueByIDRaw(
        requestParameters: UpdateIssueByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Issue>>;

    /**
     * Update Issue (By Issue ID)
     */
    updateIssueByID(
        requestParameters: UpdateIssueByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Issue>;
}

/**
 *
 */
export class IssuesApi extends runtime.BaseAPI implements IssuesApiInterface {
    /**
     * Create Issue in Repository
     */
    async createIssueRaw(
        requestParameters: CreateIssueRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Issue>> {
        if (requestParameters["orgSlug"] == null) {
            throw new runtime.RequiredError(
                "orgSlug",
                'Required parameter "orgSlug" was null or undefined when calling createIssue().'
            );
        }

        if (requestParameters["repoSlug"] == null) {
            throw new runtime.RequiredError(
                "repoSlug",
                'Required parameter "repoSlug" was null or undefined when calling createIssue().'
            );
        }

        if (requestParameters["createIssueBody"] == null) {
            throw new runtime.RequiredError(
                "createIssueBody",
                'Required parameter "createIssueBody" was null or undefined when calling createIssue().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["silent"] != null) {
            queryParameters["silent"] = requestParameters["silent"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/issues`;
        urlPath = urlPath.replace(
            `{${"org_slug"}}`,
            encodeURIComponent(String(requestParameters["orgSlug"]))
        );
        urlPath = urlPath.replace(
            `{${"repo_slug"}}`,
            encodeURIComponent(String(requestParameters["repoSlug"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: CreateIssueBodyToJSON(requestParameters["createIssueBody"]),
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => IssueFromJSON(jsonValue));
    }

    /**
     * Create Issue in Repository
     */
    async createIssue(
        requestParameters: CreateIssueRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Issue> {
        const response = await this.createIssueRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Issue in Repository (By Repo ID)
     */
    async createIssueByIDRaw(
        requestParameters: CreateIssueByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Issue>> {
        if (requestParameters["repoId"] == null) {
            throw new runtime.RequiredError(
                "repoId",
                'Required parameter "repoId" was null or undefined when calling createIssueByID().'
            );
        }

        if (requestParameters["createIssueBody"] == null) {
            throw new runtime.RequiredError(
                "createIssueBody",
                'Required parameter "createIssueBody" was null or undefined when calling createIssueByID().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["silent"] != null) {
            queryParameters["silent"] = requestParameters["silent"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/id:{repo_id}/issues`;
        urlPath = urlPath.replace(
            `{${"repo_id"}}`,
            encodeURIComponent(String(requestParameters["repoId"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: CreateIssueBodyToJSON(requestParameters["createIssueBody"]),
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => IssueFromJSON(jsonValue));
    }

    /**
     * Create Issue in Repository (By Repo ID)
     */
    async createIssueByID(
        requestParameters: CreateIssueByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Issue> {
        const response = await this.createIssueByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete Issue
     */
    async deleteIssueRaw(
        requestParameters: DeleteIssueRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<void>> {
        if (requestParameters["orgSlug"] == null) {
            throw new runtime.RequiredError(
                "orgSlug",
                'Required parameter "orgSlug" was null or undefined when calling deleteIssue().'
            );
        }

        if (requestParameters["repoSlug"] == null) {
            throw new runtime.RequiredError(
                "repoSlug",
                'Required parameter "repoSlug" was null or undefined when calling deleteIssue().'
            );
        }

        if (requestParameters["issueSlug"] == null) {
            throw new runtime.RequiredError(
                "issueSlug",
                'Required parameter "issueSlug" was null or undefined when calling deleteIssue().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["silent"] != null) {
            queryParameters["silent"] = requestParameters["silent"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/issues/{issue_slug}`;
        urlPath = urlPath.replace(
            `{${"org_slug"}}`,
            encodeURIComponent(String(requestParameters["orgSlug"]))
        );
        urlPath = urlPath.replace(
            `{${"repo_slug"}}`,
            encodeURIComponent(String(requestParameters["repoSlug"]))
        );
        urlPath = urlPath.replace(
            `{${"issue_slug"}}`,
            encodeURIComponent(String(requestParameters["issueSlug"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "DELETE",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Issue
     */
    async deleteIssue(
        requestParameters: DeleteIssueRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<void> {
        await this.deleteIssueRaw(requestParameters, initOverrides);
    }

    /**
     * Delete Issue (By Issue ID)
     */
    async deleteIssueByIDRaw(
        requestParameters: DeleteIssueByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<void>> {
        if (requestParameters["issueId"] == null) {
            throw new runtime.RequiredError(
                "issueId",
                'Required parameter "issueId" was null or undefined when calling deleteIssueByID().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["silent"] != null) {
            queryParameters["silent"] = requestParameters["silent"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/issues/id:{issue_id}`;
        urlPath = urlPath.replace(
            `{${"issue_id"}}`,
            encodeURIComponent(String(requestParameters["issueId"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "DELETE",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Issue (By Issue ID)
     */
    async deleteIssueByID(
        requestParameters: DeleteIssueByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<void> {
        await this.deleteIssueByIDRaw(requestParameters, initOverrides);
    }

    /**
     * Get Issue
     */
    async getIssueRaw(
        requestParameters: GetIssueRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Issue>> {
        if (requestParameters["orgSlug"] == null) {
            throw new runtime.RequiredError(
                "orgSlug",
                'Required parameter "orgSlug" was null or undefined when calling getIssue().'
            );
        }

        if (requestParameters["repoSlug"] == null) {
            throw new runtime.RequiredError(
                "repoSlug",
                'Required parameter "repoSlug" was null or undefined when calling getIssue().'
            );
        }

        if (requestParameters["issueSlug"] == null) {
            throw new runtime.RequiredError(
                "issueSlug",
                'Required parameter "issueSlug" was null or undefined when calling getIssue().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/issues/{issue_slug}`;
        urlPath = urlPath.replace(
            `{${"org_slug"}}`,
            encodeURIComponent(String(requestParameters["orgSlug"]))
        );
        urlPath = urlPath.replace(
            `{${"repo_slug"}}`,
            encodeURIComponent(String(requestParameters["repoSlug"]))
        );
        urlPath = urlPath.replace(
            `{${"issue_slug"}}`,
            encodeURIComponent(String(requestParameters["issueSlug"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => IssueFromJSON(jsonValue));
    }

    /**
     * Get Issue
     */
    async getIssue(
        requestParameters: GetIssueRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Issue> {
        const response = await this.getIssueRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Issue (By ID)
     */
    async getIssueByIDRaw(
        requestParameters: GetIssueByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Issue>> {
        if (requestParameters["issueId"] == null) {
            throw new runtime.RequiredError(
                "issueId",
                'Required parameter "issueId" was null or undefined when calling getIssueByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/issues/id:{issue_id}`;
        urlPath = urlPath.replace(
            `{${"issue_id"}}`,
            encodeURIComponent(String(requestParameters["issueId"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => IssueFromJSON(jsonValue));
    }

    /**
     * Get Issue (By ID)
     */
    async getIssueByID(
        requestParameters: GetIssueByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Issue> {
        const response = await this.getIssueByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of issues that are either assigned to or created by the currently authenticated user.
     * My Issues
     */
    async listIssuesAssignedToAuthenticatedUserRaw(
        requestParameters: ListIssuesAssignedToAuthenticatedUserRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<ListIssuesAssignedToAuthenticatedUserResponse>> {
        const queryParameters: any = {};

        if (requestParameters["pageSize"] != null) {
            queryParameters["page_size"] = requestParameters["pageSize"];
        }

        if (requestParameters["pageToken"] != null) {
            queryParameters["page_token"] = requestParameters["pageToken"];
        }

        if (requestParameters["sortBy"] != null) {
            queryParameters["sort_by"] = requestParameters["sortBy"];
        }

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/me/issues`;

        const response = await this.request(
            {
                path: urlPath,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) =>
            ListIssuesAssignedToAuthenticatedUserResponseFromJSON(jsonValue)
        );
    }

    /**
     * Returns a list of issues that are either assigned to or created by the currently authenticated user.
     * My Issues
     */
    async listIssuesAssignedToAuthenticatedUser(
        requestParameters: ListIssuesAssignedToAuthenticatedUserRequest = {},
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<ListIssuesAssignedToAuthenticatedUserResponse> {
        const response = await this.listIssuesAssignedToAuthenticatedUserRaw(
            requestParameters,
            initOverrides
        );
        return await response.value();
    }

    /**
     * List Repository Issues
     */
    async listRepositoryIssuesRaw(
        requestParameters: ListRepositoryIssuesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<ListRepositoryIssuesResponse>> {
        if (requestParameters["orgSlug"] == null) {
            throw new runtime.RequiredError(
                "orgSlug",
                'Required parameter "orgSlug" was null or undefined when calling listRepositoryIssues().'
            );
        }

        if (requestParameters["repoSlug"] == null) {
            throw new runtime.RequiredError(
                "repoSlug",
                'Required parameter "repoSlug" was null or undefined when calling listRepositoryIssues().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["pageSize"] != null) {
            queryParameters["page_size"] = requestParameters["pageSize"];
        }

        if (requestParameters["pageToken"] != null) {
            queryParameters["page_token"] = requestParameters["pageToken"];
        }

        if (requestParameters["sortBy"] != null) {
            queryParameters["sort_by"] = requestParameters["sortBy"];
        }

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/issues`;
        urlPath = urlPath.replace(
            `{${"org_slug"}}`,
            encodeURIComponent(String(requestParameters["orgSlug"]))
        );
        urlPath = urlPath.replace(
            `{${"repo_slug"}}`,
            encodeURIComponent(String(requestParameters["repoSlug"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) =>
            ListRepositoryIssuesResponseFromJSON(jsonValue)
        );
    }

    /**
     * List Repository Issues
     */
    async listRepositoryIssues(
        requestParameters: ListRepositoryIssuesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<ListRepositoryIssuesResponse> {
        const response = await this.listRepositoryIssuesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Repository Issues (By Repo ID)
     */
    async listRepositoryIssuesByIDRaw(
        requestParameters: ListRepositoryIssuesByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<ListRepositoryIssuesResponse>> {
        if (requestParameters["repoId"] == null) {
            throw new runtime.RequiredError(
                "repoId",
                'Required parameter "repoId" was null or undefined when calling listRepositoryIssuesByID().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["pageSize"] != null) {
            queryParameters["page_size"] = requestParameters["pageSize"];
        }

        if (requestParameters["pageToken"] != null) {
            queryParameters["page_token"] = requestParameters["pageToken"];
        }

        if (requestParameters["sortBy"] != null) {
            queryParameters["sort_by"] = requestParameters["sortBy"];
        }

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/id:{repo_id}/issues`;
        urlPath = urlPath.replace(
            `{${"repo_id"}}`,
            encodeURIComponent(String(requestParameters["repoId"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) =>
            ListRepositoryIssuesResponseFromJSON(jsonValue)
        );
    }

    /**
     * List Repository Issues (By Repo ID)
     */
    async listRepositoryIssuesByID(
        requestParameters: ListRepositoryIssuesByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<ListRepositoryIssuesResponse> {
        const response = await this.listRepositoryIssuesByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Issue
     */
    async updateIssueRaw(
        requestParameters: UpdateIssueRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Issue>> {
        if (requestParameters["orgSlug"] == null) {
            throw new runtime.RequiredError(
                "orgSlug",
                'Required parameter "orgSlug" was null or undefined when calling updateIssue().'
            );
        }

        if (requestParameters["repoSlug"] == null) {
            throw new runtime.RequiredError(
                "repoSlug",
                'Required parameter "repoSlug" was null or undefined when calling updateIssue().'
            );
        }

        if (requestParameters["issueSlug"] == null) {
            throw new runtime.RequiredError(
                "issueSlug",
                'Required parameter "issueSlug" was null or undefined when calling updateIssue().'
            );
        }

        if (requestParameters["updateIssueBody"] == null) {
            throw new runtime.RequiredError(
                "updateIssueBody",
                'Required parameter "updateIssueBody" was null or undefined when calling updateIssue().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["silent"] != null) {
            queryParameters["silent"] = requestParameters["silent"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/issues/{issue_slug}`;
        urlPath = urlPath.replace(
            `{${"org_slug"}}`,
            encodeURIComponent(String(requestParameters["orgSlug"]))
        );
        urlPath = urlPath.replace(
            `{${"repo_slug"}}`,
            encodeURIComponent(String(requestParameters["repoSlug"]))
        );
        urlPath = urlPath.replace(
            `{${"issue_slug"}}`,
            encodeURIComponent(String(requestParameters["issueSlug"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "PATCH",
                headers: headerParameters,
                query: queryParameters,
                body: UpdateIssueBodyToJSON(requestParameters["updateIssueBody"]),
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => IssueFromJSON(jsonValue));
    }

    /**
     * Update Issue
     */
    async updateIssue(
        requestParameters: UpdateIssueRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Issue> {
        const response = await this.updateIssueRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Issue (By Issue ID)
     */
    async updateIssueByIDRaw(
        requestParameters: UpdateIssueByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<Issue>> {
        if (requestParameters["issueId"] == null) {
            throw new runtime.RequiredError(
                "issueId",
                'Required parameter "issueId" was null or undefined when calling updateIssueByID().'
            );
        }

        if (requestParameters["updateIssueBody"] == null) {
            throw new runtime.RequiredError(
                "updateIssueBody",
                'Required parameter "updateIssueBody" was null or undefined when calling updateIssueByID().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters["silent"] != null) {
            queryParameters["silent"] = requestParameters["silent"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/issues/id:{issue_id}`;
        urlPath = urlPath.replace(
            `{${"issue_id"}}`,
            encodeURIComponent(String(requestParameters["issueId"]))
        );

        const response = await this.request(
            {
                path: urlPath,
                method: "PATCH",
                headers: headerParameters,
                query: queryParameters,
                body: UpdateIssueBodyToJSON(requestParameters["updateIssueBody"]),
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => IssueFromJSON(jsonValue));
    }

    /**
     * Update Issue (By Issue ID)
     */
    async updateIssueByID(
        requestParameters: UpdateIssueByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Issue> {
        const response = await this.updateIssueByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
