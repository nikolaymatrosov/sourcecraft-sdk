/* tslint:disable */
/* eslint-disable */
/**
 * SourceCraft API
 * Bleeding edge of Public REST API of SourceCraft
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: info@sourcecraft.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AddRepoRolesBody,
  ApiErrorResponse,
  CreateRepositoryBody,
  ForkRepositoryBody,
  ListBranchesResponse,
  ListTagsResponse,
  ListTreeResponse,
  RemoveRepoRolesBody,
  Repository,
  UpdateRepositoryBody,
} from '../models/index';
import {
    AddRepoRolesBodyFromJSON,
    AddRepoRolesBodyToJSON,
    ApiErrorResponseFromJSON,
    ApiErrorResponseToJSON,
    CreateRepositoryBodyFromJSON,
    CreateRepositoryBodyToJSON,
    ForkRepositoryBodyFromJSON,
    ForkRepositoryBodyToJSON,
    ListBranchesResponseFromJSON,
    ListBranchesResponseToJSON,
    ListTagsResponseFromJSON,
    ListTagsResponseToJSON,
    ListTreeResponseFromJSON,
    ListTreeResponseToJSON,
    RemoveRepoRolesBodyFromJSON,
    RemoveRepoRolesBodyToJSON,
    RepositoryFromJSON,
    RepositoryToJSON,
    UpdateRepositoryBodyFromJSON,
    UpdateRepositoryBodyToJSON,
} from '../models/index';

export interface AddRepoRolesRequest {
    orgSlug: string;
    repoSlug: string;
    addRepoRolesBody: AddRepoRolesBody;
}

export interface AddRepoRolesByIDRequest {
    repoId: string;
    addRepoRolesBody: AddRepoRolesBody;
}

export interface CreateRepositoryRequest {
    orgSlug: string;
    createRepositoryBody: CreateRepositoryBody;
    orgId?: string;
}

export interface CreateRepositoryByIDRequest {
    orgId: string;
    createRepositoryBody: CreateRepositoryBody;
}

export interface DeleteRepositoryRequest {
    orgSlug: string;
    repoSlug: string;
    silent?: boolean;
}

export interface DeleteRepositoryByIDRequest {
    repoId: string;
    silent?: boolean;
}

export interface ForkRepositoryRequest {
    orgSlug: string;
    repoSlug: string;
    forkRepositoryBody: ForkRepositoryBody;
}

export interface ForkRepositoryByIDRequest {
    repoId: string;
    forkRepositoryBody: ForkRepositoryBody;
}

export interface GetRepositoryRequest {
    orgSlug: string;
    repoSlug: string;
}

export interface GetRepositoryByIDRequest {
    repoId: string;
}

export interface ListBranchesRequest {
    orgSlug: string;
    repoSlug: string;
    filter?: string;
    sortBy?: string;
    pageSize?: string;
    pageToken?: string;
}

export interface ListBranchesByIDRequest {
    repoId: string;
    filter?: string;
    sortBy?: string;
    pageSize?: string;
    pageToken?: string;
}

export interface ListRepoRolesRequest {
    orgSlug: string;
    repoSlug: string;
    pageSize?: string;
    pageToken?: string;
    sortBy?: string;
}

export interface ListRepoRolesByIDRequest {
    repoId: string;
    pageSize?: string;
    pageToken?: string;
    sortBy?: string;
}

export interface ListTagsRequest {
    orgSlug: string;
    repoSlug: string;
    filter?: string;
    sortBy?: string;
    pageSize?: string;
    pageToken?: string;
}

export interface ListTagsByIDRequest {
    repoId: string;
    filter?: string;
    sortBy?: string;
    pageSize?: string;
    pageToken?: string;
}

export interface ListTreeRequest {
    orgSlug: string;
    repoSlug: string;
    revision?: string;
    path?: string;
    recursive?: boolean;
    pageSize?: string;
    pageToken?: string;
}

export interface ListTreeByIDRequest {
    repoId: string;
    revision?: string;
    path?: string;
    recursive?: boolean;
    pageSize?: string;
    pageToken?: string;
}

export interface RemoveRepoRolesRequest {
    orgSlug: string;
    repoSlug: string;
    removeRepoRolesBody: RemoveRepoRolesBody;
}

export interface RemoveRepoRolesByIDRequest {
    repoId: string;
    removeRepoRolesBody: RemoveRepoRolesBody;
}

export interface UpdateRepositoryRequest {
    orgSlug: string;
    repoSlug: string;
    updateRepositoryBody: UpdateRepositoryBody;
    silent?: boolean;
}

export interface UpdateRepositoryByIDRequest {
    repoId: string;
    updateRepositoryBody: UpdateRepositoryBody;
    silent?: boolean;
}

/**
 * 
 */
export class RepositoryApi extends runtime.BaseAPI {

    /**
     * Add Repository Roles
     */
    async addRepoRolesRaw(requestParameters: AddRepoRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['orgSlug'] == null) {
            throw new runtime.RequiredError(
                'orgSlug',
                'Required parameter "orgSlug" was null or undefined when calling addRepoRoles().'
            );
        }

        if (requestParameters['repoSlug'] == null) {
            throw new runtime.RequiredError(
                'repoSlug',
                'Required parameter "repoSlug" was null or undefined when calling addRepoRoles().'
            );
        }

        if (requestParameters['addRepoRolesBody'] == null) {
            throw new runtime.RequiredError(
                'addRepoRolesBody',
                'Required parameter "addRepoRolesBody" was null or undefined when calling addRepoRoles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/roles`;
        urlPath = urlPath.replace(`{${"org_slug"}}`, encodeURIComponent(String(requestParameters['orgSlug'])));
        urlPath = urlPath.replace(`{${"repo_slug"}}`, encodeURIComponent(String(requestParameters['repoSlug'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddRepoRolesBodyToJSON(requestParameters['addRepoRolesBody']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Add Repository Roles
     */
    async addRepoRoles(requestParameters: AddRepoRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.addRepoRolesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add Repository Roles (By ID)
     */
    async addRepoRolesByIDRaw(requestParameters: AddRepoRolesByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling addRepoRolesByID().'
            );
        }

        if (requestParameters['addRepoRolesBody'] == null) {
            throw new runtime.RequiredError(
                'addRepoRolesBody',
                'Required parameter "addRepoRolesBody" was null or undefined when calling addRepoRolesByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/id:{repo_id}/roles`;
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddRepoRolesBodyToJSON(requestParameters['addRepoRolesBody']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Add Repository Roles (By ID)
     */
    async addRepoRolesByID(requestParameters: AddRepoRolesByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.addRepoRolesByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Repository in Organization
     */
    async createRepositoryRaw(requestParameters: CreateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Repository>> {
        if (requestParameters['orgSlug'] == null) {
            throw new runtime.RequiredError(
                'orgSlug',
                'Required parameter "orgSlug" was null or undefined when calling createRepository().'
            );
        }

        if (requestParameters['createRepositoryBody'] == null) {
            throw new runtime.RequiredError(
                'createRepositoryBody',
                'Required parameter "createRepositoryBody" was null or undefined when calling createRepository().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['orgId'] != null) {
            queryParameters['org_id'] = requestParameters['orgId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/orgs/{org_slug}/repos`;
        urlPath = urlPath.replace(`{${"org_slug"}}`, encodeURIComponent(String(requestParameters['orgSlug'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateRepositoryBodyToJSON(requestParameters['createRepositoryBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RepositoryFromJSON(jsonValue));
    }

    /**
     * Create Repository in Organization
     */
    async createRepository(requestParameters: CreateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Repository> {
        const response = await this.createRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Repository in Organization (By Organization ID)
     */
    async createRepositoryByIDRaw(requestParameters: CreateRepositoryByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Repository>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createRepositoryByID().'
            );
        }

        if (requestParameters['createRepositoryBody'] == null) {
            throw new runtime.RequiredError(
                'createRepositoryBody',
                'Required parameter "createRepositoryBody" was null or undefined when calling createRepositoryByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/orgs/id:{org_id}/repos`;
        urlPath = urlPath.replace(`{${"org_id"}}`, encodeURIComponent(String(requestParameters['orgId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateRepositoryBodyToJSON(requestParameters['createRepositoryBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RepositoryFromJSON(jsonValue));
    }

    /**
     * Create Repository in Organization (By Organization ID)
     */
    async createRepositoryByID(requestParameters: CreateRepositoryByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Repository> {
        const response = await this.createRepositoryByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete Repository
     */
    async deleteRepositoryRaw(requestParameters: DeleteRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgSlug'] == null) {
            throw new runtime.RequiredError(
                'orgSlug',
                'Required parameter "orgSlug" was null or undefined when calling deleteRepository().'
            );
        }

        if (requestParameters['repoSlug'] == null) {
            throw new runtime.RequiredError(
                'repoSlug',
                'Required parameter "repoSlug" was null or undefined when calling deleteRepository().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['silent'] != null) {
            queryParameters['silent'] = requestParameters['silent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/{org_slug}/{repo_slug}`;
        urlPath = urlPath.replace(`{${"org_slug"}}`, encodeURIComponent(String(requestParameters['orgSlug'])));
        urlPath = urlPath.replace(`{${"repo_slug"}}`, encodeURIComponent(String(requestParameters['repoSlug'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Repository
     */
    async deleteRepository(requestParameters: DeleteRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRepositoryRaw(requestParameters, initOverrides);
    }

    /**
     * Delete Repository (By Repository ID)
     */
    async deleteRepositoryByIDRaw(requestParameters: DeleteRepositoryByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling deleteRepositoryByID().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['silent'] != null) {
            queryParameters['silent'] = requestParameters['silent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/id:{repo_id}`;
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Repository (By Repository ID)
     */
    async deleteRepositoryByID(requestParameters: DeleteRepositoryByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRepositoryByIDRaw(requestParameters, initOverrides);
    }

    /**
     * Fork Repository
     */
    async forkRepositoryRaw(requestParameters: ForkRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Repository>> {
        if (requestParameters['orgSlug'] == null) {
            throw new runtime.RequiredError(
                'orgSlug',
                'Required parameter "orgSlug" was null or undefined when calling forkRepository().'
            );
        }

        if (requestParameters['repoSlug'] == null) {
            throw new runtime.RequiredError(
                'repoSlug',
                'Required parameter "repoSlug" was null or undefined when calling forkRepository().'
            );
        }

        if (requestParameters['forkRepositoryBody'] == null) {
            throw new runtime.RequiredError(
                'forkRepositoryBody',
                'Required parameter "forkRepositoryBody" was null or undefined when calling forkRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/fork`;
        urlPath = urlPath.replace(`{${"org_slug"}}`, encodeURIComponent(String(requestParameters['orgSlug'])));
        urlPath = urlPath.replace(`{${"repo_slug"}}`, encodeURIComponent(String(requestParameters['repoSlug'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ForkRepositoryBodyToJSON(requestParameters['forkRepositoryBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RepositoryFromJSON(jsonValue));
    }

    /**
     * Fork Repository
     */
    async forkRepository(requestParameters: ForkRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Repository> {
        const response = await this.forkRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fork Repository (By ID)
     */
    async forkRepositoryByIDRaw(requestParameters: ForkRepositoryByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Repository>> {
        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling forkRepositoryByID().'
            );
        }

        if (requestParameters['forkRepositoryBody'] == null) {
            throw new runtime.RequiredError(
                'forkRepositoryBody',
                'Required parameter "forkRepositoryBody" was null or undefined when calling forkRepositoryByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/id:{repo_id}/fork`;
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ForkRepositoryBodyToJSON(requestParameters['forkRepositoryBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RepositoryFromJSON(jsonValue));
    }

    /**
     * Fork Repository (By ID)
     */
    async forkRepositoryByID(requestParameters: ForkRepositoryByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Repository> {
        const response = await this.forkRepositoryByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Repository
     */
    async getRepositoryRaw(requestParameters: GetRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Repository>> {
        if (requestParameters['orgSlug'] == null) {
            throw new runtime.RequiredError(
                'orgSlug',
                'Required parameter "orgSlug" was null or undefined when calling getRepository().'
            );
        }

        if (requestParameters['repoSlug'] == null) {
            throw new runtime.RequiredError(
                'repoSlug',
                'Required parameter "repoSlug" was null or undefined when calling getRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}`;
        urlPath = urlPath.replace(`{${"org_slug"}}`, encodeURIComponent(String(requestParameters['orgSlug'])));
        urlPath = urlPath.replace(`{${"repo_slug"}}`, encodeURIComponent(String(requestParameters['repoSlug'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RepositoryFromJSON(jsonValue));
    }

    /**
     * Get Repository
     */
    async getRepository(requestParameters: GetRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Repository> {
        const response = await this.getRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Repository (By ID)
     */
    async getRepositoryByIDRaw(requestParameters: GetRepositoryByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Repository>> {
        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling getRepositoryByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/id:{repo_id}`;
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RepositoryFromJSON(jsonValue));
    }

    /**
     * Get Repository (By ID)
     */
    async getRepositoryByID(requestParameters: GetRepositoryByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Repository> {
        const response = await this.getRepositoryByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Repository Branches
     */
    async listBranchesRaw(requestParameters: ListBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListBranchesResponse>> {
        if (requestParameters['orgSlug'] == null) {
            throw new runtime.RequiredError(
                'orgSlug',
                'Required parameter "orgSlug" was null or undefined when calling listBranches().'
            );
        }

        if (requestParameters['repoSlug'] == null) {
            throw new runtime.RequiredError(
                'repoSlug',
                'Required parameter "repoSlug" was null or undefined when calling listBranches().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['sortBy'] != null) {
            queryParameters['sort_by'] = requestParameters['sortBy'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['pageToken'] != null) {
            queryParameters['page_token'] = requestParameters['pageToken'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/branches`;
        urlPath = urlPath.replace(`{${"org_slug"}}`, encodeURIComponent(String(requestParameters['orgSlug'])));
        urlPath = urlPath.replace(`{${"repo_slug"}}`, encodeURIComponent(String(requestParameters['repoSlug'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListBranchesResponseFromJSON(jsonValue));
    }

    /**
     * List Repository Branches
     */
    async listBranches(requestParameters: ListBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListBranchesResponse> {
        const response = await this.listBranchesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Repository Branches (By Repo ID)
     */
    async listBranchesByIDRaw(requestParameters: ListBranchesByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListBranchesResponse>> {
        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling listBranchesByID().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['sortBy'] != null) {
            queryParameters['sort_by'] = requestParameters['sortBy'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['pageToken'] != null) {
            queryParameters['page_token'] = requestParameters['pageToken'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/id:{repo_id}/branches`;
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListBranchesResponseFromJSON(jsonValue));
    }

    /**
     * List Repository Branches (By Repo ID)
     */
    async listBranchesByID(requestParameters: ListBranchesByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListBranchesResponse> {
        const response = await this.listBranchesByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Repository Roles
     */
    async listRepoRolesRaw(requestParameters: ListRepoRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['orgSlug'] == null) {
            throw new runtime.RequiredError(
                'orgSlug',
                'Required parameter "orgSlug" was null or undefined when calling listRepoRoles().'
            );
        }

        if (requestParameters['repoSlug'] == null) {
            throw new runtime.RequiredError(
                'repoSlug',
                'Required parameter "repoSlug" was null or undefined when calling listRepoRoles().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['pageToken'] != null) {
            queryParameters['page_token'] = requestParameters['pageToken'];
        }

        if (requestParameters['sortBy'] != null) {
            queryParameters['sort_by'] = requestParameters['sortBy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/roles`;
        urlPath = urlPath.replace(`{${"org_slug"}}`, encodeURIComponent(String(requestParameters['orgSlug'])));
        urlPath = urlPath.replace(`{${"repo_slug"}}`, encodeURIComponent(String(requestParameters['repoSlug'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * List Repository Roles
     */
    async listRepoRoles(requestParameters: ListRepoRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.listRepoRolesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Repository Roles (By ID)
     */
    async listRepoRolesByIDRaw(requestParameters: ListRepoRolesByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling listRepoRolesByID().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['pageToken'] != null) {
            queryParameters['page_token'] = requestParameters['pageToken'];
        }

        if (requestParameters['sortBy'] != null) {
            queryParameters['sort_by'] = requestParameters['sortBy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/id:{repo_id}/roles`;
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * List Repository Roles (By ID)
     */
    async listRepoRolesByID(requestParameters: ListRepoRolesByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.listRepoRolesByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Repository Tags
     */
    async listTagsRaw(requestParameters: ListTagsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListTagsResponse>> {
        if (requestParameters['orgSlug'] == null) {
            throw new runtime.RequiredError(
                'orgSlug',
                'Required parameter "orgSlug" was null or undefined when calling listTags().'
            );
        }

        if (requestParameters['repoSlug'] == null) {
            throw new runtime.RequiredError(
                'repoSlug',
                'Required parameter "repoSlug" was null or undefined when calling listTags().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['sortBy'] != null) {
            queryParameters['sort_by'] = requestParameters['sortBy'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['pageToken'] != null) {
            queryParameters['page_token'] = requestParameters['pageToken'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/tags`;
        urlPath = urlPath.replace(`{${"org_slug"}}`, encodeURIComponent(String(requestParameters['orgSlug'])));
        urlPath = urlPath.replace(`{${"repo_slug"}}`, encodeURIComponent(String(requestParameters['repoSlug'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListTagsResponseFromJSON(jsonValue));
    }

    /**
     * List Repository Tags
     */
    async listTags(requestParameters: ListTagsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListTagsResponse> {
        const response = await this.listTagsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Repository Tags (By Repo ID)
     */
    async listTagsByIDRaw(requestParameters: ListTagsByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListTagsResponse>> {
        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling listTagsByID().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['sortBy'] != null) {
            queryParameters['sort_by'] = requestParameters['sortBy'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['pageToken'] != null) {
            queryParameters['page_token'] = requestParameters['pageToken'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/id:{repo_id}/tags`;
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListTagsResponseFromJSON(jsonValue));
    }

    /**
     * List Repository Tags (By Repo ID)
     */
    async listTagsByID(requestParameters: ListTagsByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListTagsResponse> {
        const response = await this.listTagsByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Repository File Tree
     */
    async listTreeRaw(requestParameters: ListTreeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListTreeResponse>> {
        if (requestParameters['orgSlug'] == null) {
            throw new runtime.RequiredError(
                'orgSlug',
                'Required parameter "orgSlug" was null or undefined when calling listTree().'
            );
        }

        if (requestParameters['repoSlug'] == null) {
            throw new runtime.RequiredError(
                'repoSlug',
                'Required parameter "repoSlug" was null or undefined when calling listTree().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['revision'] != null) {
            queryParameters['revision'] = requestParameters['revision'];
        }

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        if (requestParameters['recursive'] != null) {
            queryParameters['recursive'] = requestParameters['recursive'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['pageToken'] != null) {
            queryParameters['page_token'] = requestParameters['pageToken'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/trees`;
        urlPath = urlPath.replace(`{${"org_slug"}}`, encodeURIComponent(String(requestParameters['orgSlug'])));
        urlPath = urlPath.replace(`{${"repo_slug"}}`, encodeURIComponent(String(requestParameters['repoSlug'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListTreeResponseFromJSON(jsonValue));
    }

    /**
     * List Repository File Tree
     */
    async listTree(requestParameters: ListTreeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListTreeResponse> {
        const response = await this.listTreeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Repository File Tree (By Repo ID)
     */
    async listTreeByIDRaw(requestParameters: ListTreeByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListTreeResponse>> {
        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling listTreeByID().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['revision'] != null) {
            queryParameters['revision'] = requestParameters['revision'];
        }

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        if (requestParameters['recursive'] != null) {
            queryParameters['recursive'] = requestParameters['recursive'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['pageToken'] != null) {
            queryParameters['page_token'] = requestParameters['pageToken'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/id:{repo_id}/trees`;
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListTreeResponseFromJSON(jsonValue));
    }

    /**
     * List Repository File Tree (By Repo ID)
     */
    async listTreeByID(requestParameters: ListTreeByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListTreeResponse> {
        const response = await this.listTreeByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove Repository Roles
     */
    async removeRepoRolesRaw(requestParameters: RemoveRepoRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['orgSlug'] == null) {
            throw new runtime.RequiredError(
                'orgSlug',
                'Required parameter "orgSlug" was null or undefined when calling removeRepoRoles().'
            );
        }

        if (requestParameters['repoSlug'] == null) {
            throw new runtime.RequiredError(
                'repoSlug',
                'Required parameter "repoSlug" was null or undefined when calling removeRepoRoles().'
            );
        }

        if (requestParameters['removeRepoRolesBody'] == null) {
            throw new runtime.RequiredError(
                'removeRepoRolesBody',
                'Required parameter "removeRepoRolesBody" was null or undefined when calling removeRepoRoles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/{org_slug}/{repo_slug}/roles/remove`;
        urlPath = urlPath.replace(`{${"org_slug"}}`, encodeURIComponent(String(requestParameters['orgSlug'])));
        urlPath = urlPath.replace(`{${"repo_slug"}}`, encodeURIComponent(String(requestParameters['repoSlug'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RemoveRepoRolesBodyToJSON(requestParameters['removeRepoRolesBody']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Remove Repository Roles
     */
    async removeRepoRoles(requestParameters: RemoveRepoRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.removeRepoRolesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove Repository Roles (By ID)
     */
    async removeRepoRolesByIDRaw(requestParameters: RemoveRepoRolesByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling removeRepoRolesByID().'
            );
        }

        if (requestParameters['removeRepoRolesBody'] == null) {
            throw new runtime.RequiredError(
                'removeRepoRolesBody',
                'Required parameter "removeRepoRolesBody" was null or undefined when calling removeRepoRolesByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/id:{repo_id}/roles/remove`;
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RemoveRepoRolesBodyToJSON(requestParameters['removeRepoRolesBody']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Remove Repository Roles (By ID)
     */
    async removeRepoRolesByID(requestParameters: RemoveRepoRolesByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.removeRepoRolesByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Repository
     */
    async updateRepositoryRaw(requestParameters: UpdateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Repository>> {
        if (requestParameters['orgSlug'] == null) {
            throw new runtime.RequiredError(
                'orgSlug',
                'Required parameter "orgSlug" was null or undefined when calling updateRepository().'
            );
        }

        if (requestParameters['repoSlug'] == null) {
            throw new runtime.RequiredError(
                'repoSlug',
                'Required parameter "repoSlug" was null or undefined when calling updateRepository().'
            );
        }

        if (requestParameters['updateRepositoryBody'] == null) {
            throw new runtime.RequiredError(
                'updateRepositoryBody',
                'Required parameter "updateRepositoryBody" was null or undefined when calling updateRepository().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['silent'] != null) {
            queryParameters['silent'] = requestParameters['silent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/{org_slug}/{repo_slug}`;
        urlPath = urlPath.replace(`{${"org_slug"}}`, encodeURIComponent(String(requestParameters['orgSlug'])));
        urlPath = urlPath.replace(`{${"repo_slug"}}`, encodeURIComponent(String(requestParameters['repoSlug'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateRepositoryBodyToJSON(requestParameters['updateRepositoryBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RepositoryFromJSON(jsonValue));
    }

    /**
     * Update Repository
     */
    async updateRepository(requestParameters: UpdateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Repository> {
        const response = await this.updateRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Repository (By Repo ID)
     */
    async updateRepositoryByIDRaw(requestParameters: UpdateRepositoryByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Repository>> {
        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling updateRepositoryByID().'
            );
        }

        if (requestParameters['updateRepositoryBody'] == null) {
            throw new runtime.RequiredError(
                'updateRepositoryBody',
                'Required parameter "updateRepositoryBody" was null or undefined when calling updateRepositoryByID().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['silent'] != null) {
            queryParameters['silent'] = requestParameters['silent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/repos/id:{repo_id}`;
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateRepositoryBodyToJSON(requestParameters['updateRepositoryBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RepositoryFromJSON(jsonValue));
    }

    /**
     * Update Repository (By Repo ID)
     */
    async updateRepositoryByID(requestParameters: UpdateRepositoryByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Repository> {
        const response = await this.updateRepositoryByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
